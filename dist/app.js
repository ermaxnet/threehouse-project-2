var source = [{
  id: 1,
  name: "Miko\u0142aj Krzysztof Radziwi\u0142\u0142 Czarny",
  email: "mikolay@radzivill.by",
  at: "1515-02-04T15:56:05+00:00",
  avatar: "./assets/images/avatars/1.jpg"
}, {
  id: 2,
  name: "Barbara Radziwi\u0142\u0142\xF3wna",
  email: "barbara@radzivill.by",
  at: "1520-12-06T15:56:05+00:00",
  avatar: "./assets/images/avatars/2.jpg"
}, {
  id: 3,
  name: "Miko\u0142aj Krzysztof Radziwi\u0142\u0142",
  email: "mikolay_k@radzivill.by",
  at: "1549-08-02T15:56:05+00:00",
  avatar: "./assets/images/avatars/3.jpg"
}, {
  id: 4,
  name: "Krzysztof Miko\u0142aj Radziwi\u0142\u0142",
  email: "piorun@radzivill.by",
  at: "1547-02-09T15:56:05+00:00",
  avatar: "./assets/images/avatars/4.png"
}, {
  id: 5,
  name: "Jerzy Radziwi\u0142\u0142",
  email: "jerzy@radzivill.by",
  at: "1591-08-02T15:56:05+00:00",
  avatar: "./assets/images/avatars/5.jpg"
}, {
  id: 6,
  name: "Stanis\u0142aw Radziwi\u0142\u0142",
  email: "stanislaw@radzivill.by",
  at: "1559-05-12T15:56:05+00:00",
  avatar: "./assets/images/avatars/6.jpg"
}, {
  id: 7,
  name: "Janusz Radziwi\u0142\u0142",
  email: "janusz@radzivill.by",
  at: "1579-07-02T15:56:05+00:00",
  avatar: "./assets/images/avatars/7.jpg"
}, {
  id: 8,
  name: "Zofia z Olelkowicz\xF3w Radziwi\u0142\u0142owa",
  email: "zofia@radzivill.by",
  at: "1585-05-11T15:56:05+00:00",
  avatar: "./assets/images/avatars/8.jpg"
}, {
  id: 9,
  name: "Krzysztof Radziwi\u0142\u0142",
  email: "kryzstof_junior@radzivill.by",
  at: "1585-03-22T15:56:05+00:00",
  avatar: "./assets/images/avatars/9.jpg"
}, {
  id: 10,
  name: "Albrycht Stanis\u0142aw Radziwi\u0142\u0142",
  email: "stanislaw_a@radzivill.by",
  at: "1595-07-01T15:56:05+00:00",
  avatar: "./assets/images/avatars/10.jpg"
}, {
  id: 11,
  name: "Janusz Radziwi\u0142\u0142",
  email: "janusz_getman@radzivill.by",
  at: "1612-12-02T15:56:05+00:00",
  avatar: "./assets/images/avatars/11.jpg"
}, {
  id: 12,
  name: "Maria Radziwi\u0142\u0142owa",
  email: "maria@radzivill.by",
  at: "1625-01-01T15:56:05+00:00",
  avatar: "./assets/images/avatars/12.jpg"
}, {
  id: 13,
  name: "Bogus\u0142aw Radziwi\u0142\u0142",
  email: "boguslaw@radzivill.by",
  at: "1620-05-03T15:56:05+00:00",
  avatar: "./assets/images/avatars/13.png"
}, {
  id: 14,
  name: "Micha\u0142 Kazimierz Radziwi\u0142\u0142",
  email: "michail@radzivill.by",
  at: "1625-10-26T15:56:05+00:00",
  avatar: "./assets/images/avatars/14.jpg"
}, {
  id: 15,
  name: "Dominik Miko\u0142aj Radziwi\u0142\u0142",
  email: "dominik@radzivill.by",
  at: "1643-01-01T15:56:05+00:00",
  avatar: "./assets/images/avatars/15.png"
}, {
  id: 16,
  name: "Ludwika Karolina Radziwi\u0142\u0142",
  email: "ludwika@radzivill.by",
  at: "1667-02-27T15:56:05+00:00",
  avatar: "./assets/images/avatars/16.jpg"
}, {
  id: 17,
  name: "Karol Stanis\u0142aw Radziwi\u0142\u0142",
  email: "karol@radzivill.by",
  at: "1669-11-27T15:56:05+00:00",
  avatar: "./assets/images/avatars/17.jpg"
}, {
  id: 18,
  name: "Jan Miko\u0142aj Radziwi\u0142\u0142",
  email: "jan@radzivill.by",
  at: "1681-05-17T15:56:05+00:00",
  avatar: "./assets/images/avatars/18.png"
}, {
  id: 19,
  name: "Miko\u0142aj Faustyn Radziwi\u0142\u0142",
  email: "mikolay@radzivill.by",
  at: "1688-05-21T15:56:05+00:00",
  avatar: "./assets/images/avatars/19.png"
}, {
  id: 20,
  name: "Micha\u0142 Kazimierz Radziwi\u0142\u0142 Rybe\u0144ko",
  email: "michal_rybenko@radzivill.by",
  at: "1702-06-13T15:56:05+00:00",
  avatar: "./assets/images/avatars/20.jpg"
}, {
  id: 21,
  name: "Franciszka Urszula Radziwi\u0142\u0142owa",
  email: "franciszka@radzivill.by",
  at: "1705-02-13T15:56:05+00:00",
  avatar: "./assets/images/avatars/21.jpg"
}, {
  id: 22,
  name: "Udalryk Krzysztof Radziwi\u0142\u0142",
  email: "udarlik@radzivill.by",
  at: "1712-01-05T15:56:05+00:00",
  avatar: "./assets/images/avatars/22.jpg"
}, {
  id: 23,
  name: "Karol Stanis\u0142aw Radziwi\u0142\u0142 Panie Kochanku",
  email: "karol_kochanku@radzivill.by",
  at: "1734-02-27T15:56:05+00:00",
  avatar: "./assets/images/avatars/23.png"
}];
{
  /* Простая реализация плавающего плэйсхолдера. В реальном проекте
     вы наверняка захотите анализировать есть ли в поле значение изначально,
     но для нашего примера это лишнее
  */
  var activePlaceholder = function activePlaceholder(element) {
    var action = function action() {
      if (element.val()) {
        element.addClass("fill");
      } else {
        element.removeClass("fill");
      }
    };

    element.on("blur clear-search-field", action);
  };
  /* Логика реализации списка инкапсулировано в jQuery-расширение.
     Т. е. выполнение задания выполнено в виде простого jQuery-плагина
  */


  $.fn.listItems = function (options) {
    // Настройки по-умолчанию
    var defaultOptions = {
      total: 10,
      enabledSearchBox: true,
      searchPlaceholder: "Start entering name or email",
      noData: "<div class=\"no-students\">\n                    <span>Ups! No students for display</span>\n                </div>",
      source: new Array(0)
    };
    options = Object.assign({}, defaultOptions, options); // Некоторые глобальные для плагина переменные

    var context = this;
    var listContext = null;
    var pagerContext = null;
    var dirty = false;
    var hasPager = false;
    /* Состояние приложение. Отдадим дань уважения Реакту, после работы на нем руки сами тянуться
       реализовывать подобную логику подобным образом
    */

    var state = {
      page: 0,
      oldPage: 0,
      source: options.source,
      total: 0,
      totalPages: 0
    };
    /* Некоторые вспомогательные методы для плагина инкапсулированы в отдельное пространство имен
       для простоты
    */

    var API = {
      /* Построение поля поиска. В моем примере я решил не делать кнопку для поиска (надеюсь это 
         не слишком большое нарушение условия задания). Я сделал простую реализацию автокомплита.
      */
      buildSearchBox: function buildSearchBox() {
        var _this = this;

        if (!this.hasSource()) {
          return;
        }

        var searchBox = $("<div class=\"search-box\">\n                        <form action=\"#\" class=\"search-box__form\">\n                            <div class=\"search-box__input\">\n                                <input type=\"search\" name=\"search\" id=\"search\" />\n                                <span class=\"active-placeholder\">".concat(options.searchPlaceholder, "</span>\n                            </div>\n                        </form>\n                    </div>"));
        context.before(searchBox);
        var search = searchBox.find("[type=\"search\"], [type=\"text\"]");
        activePlaceholder(search); // На всякий случай отключить отправку форму по нажатию Ентер

        searchBox.find("form").on("keyup keypress", function (e) {
          var keyCode = e.keyCode || e.which;

          if (keyCode === 13) {
            e.preventDefault();
            return false;
          }
        });
        /* Собственно логика поиска. По срабатыванию события input если присутствует введенное
           значение, то ищем совпадение среди имен и имэйлов. Если значение отсутсвует, то загружаем
           исходный список. Разумеется, в реальном проекте вам может захотеться ограничить начало поиска
           определенным количеством символов или же частоту вызовов методом на подобие debounce, но тут
           я этого не делал. Опять же, да, я знаю, что событие input не работает в старых IE
           и для них существует onpropertychange, но нам в 2018 не следует ориентироваться на 
           IE8. ВАЖНО: фильтр осуществляет поиск по наличию введенного буквосочетания (просто мне
           кажется что так инетерсней)
        */

        search.on("input", function (e) {
          var value = $(e.target).val();

          if (value) {
            var _source = options.source.filter(function (item) {
              var pattern = new RegExp(value, "i");
              return pattern.test(item.name) || pattern.test(item.email);
            });

            var newState = {
              source: _source,
              page: 0
            };
            /*Сохраняем выбранную страницу, для того чтобы на нее вернуться, когда пользователь
              очистит поле поиска
            */

            if (state.page) {
              newState.oldPage = state.page;
            }

            state = Object.assign({}, state, newState);

            _this.build();
          } else {
            state = Object.assign({}, state, {
              source: options.source,
              page: state.oldPage
            });

            _this.build();
          }
        });
      },

      /* Строим пагинацию если она нужна (т. е. если у нас данных больше чем на одну страницу).
         Построение основано на текущем состоянии объекта state 
      */
      buildPager: function buildPager() {
        var pager = "<div class=\"pager-box\">\n                        <ol class=\"pager\">[pages]</ol>\n                        <div class=\"pager__range-mark\">\n                            <span class=\"range\"></span>\n                            <span>out of</span>\n                            <span class=\"count\">".concat(state.total, "</span>\n                        </div>\n                    </div>");
        var pages = "";

        for (var i = 0; i < state.totalPages; i++) {
          pages += "<li class=\"page".concat(i === state.page ? " state_active" : "", "\" data-page=\"").concat(i, "\">\n                            ").concat(i + 1, "\n                        </li>");
        }

        pager = pager.replace(/\[pages\]/i, pages);
        context.after(pager);
        pagerContext = $(".pager-box");
      },

      /* Добавление в ДОМ элемента списка. Методо очень прост, но я вынес его отдельно для
         сохранения модульной системы плагина (и на будущее, мало ли что понадобиться)
      */
      buildList: function buildList() {
        listContext = $("<ul class=\"students__list\"></ul>");
        context.prepend(listContext);
      },

      /* Добавить новый элемент в список по шаблону
      */
      buildItem: function buildItem(item) {
        listContext.append("<li class=\"students__item student\" data-item-id=\"".concat(item.id, "\">\n                        <div class=\"student__avatar\">\n                            <img alt=\"").concat(item.name, "\" src=\"").concat(item.avatar, "\" />\n                        </div>\n                        <div class=\"student__contact\">\n                            <div class=\"student__name\">\n                                <span>").concat(item.name, "</span>\n                            </div>\n                            <div class=\"student__email\">\n                                <a href=\"mailto:").concat(item.email, "\">").concat(item.email, "</a>\n                            </div>\n                        </div>\n                        <div class=\"mark\">\n                            <span>Born</span>\n                            <time datetime=\"").concat(item.at, "\">\n                                ").concat(new Date(item.at).toLocaleDateString(), "\n                            </time>\n                        </div>\n                    </li>"));
      },

      /* Удаление всех программно созданных элементов из ДОМ и очистка 
         глобальных переменных перед перерисовкой списка
      */
      clear: function clear() {
        if (dirty) {
          context.html("");
          dirty = false;
          listContext = null;
        }

        if (hasPager && pagerContext) {
          pagerContext.remove();
          hasPager = false;
          pagerContext = null;
        }
      },
      // Получение элементов для текущей страницы из состояния
      getItems: function getItems() {
        var lastIndex = state.total - 1;
        var startIndex = state.page * options.total;
        var endIndex = startIndex + options.total - 1;

        if (endIndex > lastIndex) {
          endIndex = lastIndex;
        }

        var items = new Array(0);

        for (var i = startIndex; i <= endIndex; i++) {
          items.push(state.source[i]);
        }

        if (hasPager) {
          var markRange = pagerContext.find(".range");
          markRange.text("".concat(startIndex + 1, " - ").concat(endIndex + 1));
        }

        return items;
      },
      // Добавить все элементы для текущей страницы в список
      buildItems: function buildItems() {
        if (!listContext) {
          return;
        }

        listContext.html("");
        var items = this.getItems();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _item = _step.value;
            this.buildItem(_item);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      },
      // Подключение возможных возможных событий для списка (например, перехода по страницам)
      bindListEvents: function bindListEvents() {
        var _this2 = this;

        if (hasPager) {
          var pages = pagerContext.find(".page");
          pages.click(function (e) {
            pages.removeClass("state_active");
            var page = $(e.target).closest("li");
            page.addClass("state_active");
            state = Object.assign({}, state, {
              page: page.data("page")
            });

            _this2.buildItems();
          });
        }
      },

      /* Есть ли в состоянии элементы для отображения? Тут я схитрил. Этот метод вызывается два раза:
         каждый раз при построении нового списка и когда отрисовывается поле для поиска. Поле для поиска
         отрисовывается один раз и поэтому метод вернет тру только если весь набор элементов для списка
         больше нуля.*/
      hasSource: function hasSource() {
        return state.source instanceof Array && state.source.length;
      },
      // Вызвать все необходимые методы попорядку и нарисовать список
      build: function build() {
        this.clear();

        if (!this.hasSource()) {
          return context.html(options.noData);
        }

        var listSize = state.source.length;
        var pagesCount = Math.ceil(listSize / options.total);
        this.buildList();
        state = Object.assign({}, state, {
          total: listSize,
          totalPages: pagesCount
        });

        if (state.totalPages > 1) {
          this.buildPager();
          hasPager = true;
        } else {
          hasPager = false;
        }

        this.buildItems();
        dirty = true;
        this.bindListEvents();
      }
    };
    /* Отрисовка списка при запуске прилодения и, если включено, поля поиска
    */

    var init = function init() {
      API.build();

      if (options.enabledSearchBox) {
        API.buildSearchBox();
      }
    };

    init();
  };

  $(document).ready(function () {
    $("#year").text(new Date().getFullYear());
    $(".students").listItems({
      source: source
    });
  });
}